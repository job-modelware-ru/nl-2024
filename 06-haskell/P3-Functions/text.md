# Haskell. Функции
Презентацию выполнили студенты гр. 5030102/10201:
- Костюхин Алексей
- Тасаков Антон
- Теплов Андрей

## Содержание

- [Определение функций](#определение-функций)
    - [Оператор `->`](#оператор--)
    - [Частичная применимость](#частичная-применимость)
    - [Функции как аргументы](#функции-как-аргументы)
    - [Лямбда-функции](#лямбда-функции)
        <!--
        - [Синтаксис лямбда-функций](#синтаксис-лямбда-функций)
        - [Особенности и ограничения](#особенности-и-ограничения)
        -->
- [Функциональные операторы](#функциональные-операторы)
    - [Определение пользовательского оператора](#определение-пользовательского-оператора)
        <!--
        - [Ассоциативность операторов](#ассоциативность-операторов)
        - [Приоритет операторов](#приоритет-операторов)
        -->
    - [Использование функций в инфиксной форме](#использование-функций-в-инфиксной-форме)
    - [Использование операторов в префиксной форме](#использование-операторов-в-префиксной-форме)
    - [Сечение операторов](#сечение-операторов)
        <!--
        - [Синтаксис сечений](#синтаксис-сечений)
        - [Примеры использования](#примеры-использования)
        -->
    - [Оператор `$`](#оператор-)
        <!--
        - [Как работает `$`](#как-работает-)
        - [Примеры применения `$`](#примеры-применения-)
        -->
- [Полиморфизм функций](#полиморфизм-функций)
    - [Параметрический полиморфизм](#параметрический-полиморфизм)
    - [Ограниченный (ад-хок) полиморфизм](#ограниченный-ад-хок-полиморфизм)
    - [Полиморфизм более высокого рода](#полиморфизм-более-высокого-рода)
- [Условные конструкции](#условные-конструкции)
    - [Конструкция `if-then-else`](#конструкция-if-then-else)
    - [Конструкция `case ... of`](#конструкция-case--of)
    - [Охранные выражения (guards)](#охранные-выражения-guards)
- [Сопоставление с образцом](#сопоставление-с-образцом)
    - [Паттерн-матчинг с примитивными типами данных](#паттерн-матчинг-с-примитивными-типами-данных)
    - [Паттерн-матчинг со списками и строками](#паттерн-матчинг-со-списками-и-строками)
        <!--
        - [Основные паттерны для списков](#основные-паттерны-для-списков)
        - [Паттерн-матчинг для строк](#паттерн-матчинг-для-строк)
        -->
    - [Паттерн-матчинг с кортежами](#паттерн-матчинг-с-кортежами)
        <!--
        - [Пример: обработка кортежа с двумя элементами](#пример-обработка-кортежа-с-двумя-элементами)
        - [Пример: Обработка кортежей с более чем двумя элементами](#пример-обработка-кортежей-с-более-чем-двумя-элементами)
        -->
    - [Паттерн-матчинг с пользовательскими типами](#паттерн-матчинг-с-пользовательскими-типами)
        <!--
        - [Пример: обработка типа Maybe](#пример-обработка-типа-maybe)
        - [Пример: обработка типа Shape](#пример-обработка-типа-shape)
        -->
- [Рекурсия](#рекурсия)
    - [Прямая рекурсия](#прямая-рекурсия)
    - [Хвостовая рекурсия](#хвостовая-рекурсия)
    - [Косвенная рекурсия](#косвенная-рекурсия)
- [Функции высшего порядка](#функции-высшего-порядка)
    - [Основные функции высшего порядка в Haskell](#основные-функции-высшего-порядка-в-haskell)
    - [Преимущества использования функций высшего порядка](#преимущества-использования-функций-высшего-порядка)

## Определение функций

### Оператор `->`
В Haskell оператор `->` используется для обозначения типов функций и является частью синтаксиса определения функций.

**Определение типа функции**: `->` указывает, что функция принимает аргумент одного типа и возвращает результат другого типа. Например, тип функции `add :: Int -> Int -> Int` показывает, что `add` принимает два аргумента типа `Int` и возвращает значение типа `Int`. При этом `Int -> Int -> Int` фактически означает `Int -> (Int -> Int)`, что функция принимает один аргумент и возвращает функцию, которая принимает следующий аргумент. Из этого вытекает правая ассоциативность оператора `->`.

```haskell
-- add :: Int -> (Int -> Int)
add :: Int -> Int -> Int
add x y = x + y
```

### Частичная применимость
В Haskell функции поддерживают частичное применение: если функция принимает несколько аргументов, то ее можно вызвать с меньшим количеством аргументов, и результатом будет новая функция. Например, в функцию `add` из примера выше можно передать только один аргумент:

```haskell
addFive :: Int -> Int
addFive = add 5
addFive 10 -- Результат: 15
```

Теперь `addFive` — это функция, принимающая одно значение `Int` и прибавляющая к нему 5.

### Функции как аргументы
Функции в Haskell можно передавать в качестве аргументов другим функциям.

```haskell
applyTwice :: (a -> a) -> a -> a
applyTwice f x = f (f x)
applyTwice addFive 2 -- Результат: 12
```

Здесь `applyTwice` принимает функцию `f` и значение `x`, применяя функцию `f` дважды к `x`.

### Лямбда-функции
Лямбда-функции в Haskell — это анонимные функции, которые используются для создания небольших, одноразовых функций без необходимости давать им имя. Лямбда-функции удобны для краткого определения логики в местах, где не нужно создавать именованную функцию.

#### Синтаксис лямбда-функций
Лямбда-функция начинается с символа `\`, за которым следует список аргументов, затем идет оператор `->` и выражение, определяющее тело функции.

Пример:
```haskell
(\x -> x + 1) 99 -- Результат: 100
```
Здесь `\x -> x + 1` — это лямбда-функция, которая принимает аргумент `x` и возвращает `x + 1`.

```haskell
(\x y -> x + y) 3 5 -- Результат: 8
```
Здесь `\x y -> x + y` — это лямбда-функция, которая принимает два аргумента `x` и `y` и возвращает их сумму.


#### Особенности и ограничения
- Лямбда-функции не могут содержать рекурсию. Если нужна рекурсивная функция, ей нужно присвоить имя.
- Лямбда-функции особенно полезны для создания компактного кода в комбинации с функциями высшего порядка и для определения одноразовых функций.

## Функциональные операторы

В Haskell операторы — это функции, которые могут быть записаны в инфиксной форме (то есть, между двумя аргументами). Большинство операторов, таких как `+`, `*` , `&&`, и `||`, встроены в язык, но также можно определять собственные операторы, устанавливая их поведение и приоритет.

### Определение пользовательского оператора

В Haskell можно создать собственный оператор, задав его символы и определив, как он будет работать. Операторы обычно начинаются с символов, таких как `+`, `*`, или `&`, и не могут содержать буквы. Пример создания оператора `***`, который будет выполнять возведение в степень:

```haskell
(***) :: Int -> Int -> Int
x *** y = x ^ y
```

Теперь `***` можно использовать как любой другой оператор:
```haskell
result = 2 *** 3  -- результат 8
```

#### Ассоциативность операторов

Ассоциативность определяет, как оператор связывается с операндами при использовании нескольких одинаковых операторов подряд. В Haskell существуют три типа ассоциативности:

- **Левая** (`infixl`): операции группируются слева, например, `1 - 2 - 3` интерпретируется как `(1 - 2) - 3`.
- **Правая** (`infixr`): операции группируются справа, например, оператор `->` (как в `a -> b -> c`) является правым.
- **Без ассоциативности** (`infix`): нельзя использовать подряд без скобок, например, операторы `==` и `/=`.

Ассоциативность настраивается при определении оператора. Например:
```haskell
infixr 5 ***
```

Здесь `infixr 5` означает, что оператор `***` является правым и имеет приоритет 5.

#### Приоритет операторов

Приоритет оператора определяет его порядок выполнения относительно других операторов. В Haskell приоритет задается числом от 0 до 9: чем выше число, тем выше приоритет. Например, `*` и `/` имеют более высокий приоритет, чем `+` и `-`, что соответствует правилам математики.

### Использование функций в инфиксной форме

Haskell позволяет использовать функции с двумя аргументами в инфиксной записи, просто окружив имя функции обратными апострофами. Это полезно для улучшения читаемости, особенно в случаях, когда функция предполагает находиться между аргументами.

```haskell
divide :: Int -> Int -> Int
divide x y = x `div` y
10 `divide` 2  -- Результат 5
```

### Использование операторов в префиксной форме

Напротив, любой оператор в Haskell можно использовать как функцию, заключив его в круглые скобки. Это превращает его в префиксную форму, что бывает полезно в случае композиции функций или частичного применения.
```haskell
(+) 2 3                 -- Результат 5
map ((+) 10) [1, 2, 3]  -- Результат [11, 12, 13]
```

Здесь `+` используется как обычная функция, принимающая два аргумента.

### Сечение операторов
Сечение операторов в Haskell — это техника, которая позволяет частично применять бинарный оператор к одному из аргументов, оставляя другой аргумент свободным. Сечения часто применяются для улучшения читабельности кода.

#### Синтаксис сечений
Сечение создается, когда оператор записывается в скобках и один из его аргументов заменяется на пустое место. Примеры:

- **Левое сечение** (частичное применение к левому аргументу):
  `(+3)` — функция, которая добавляет 3 к своему аргументу.
  Интерпретируется как `\x -> x + 3`.

- **Правое сечение** (частичное применение к правому аргументу):
  `(3+)` — функция, которая также добавляет 3 к своему аргументу.
  Интерпретируется как `\x -> 3 + x`.

#### Примеры использования

1. **Сечение для сложения**:
   ```haskell
   increment = (+1)      -- Функция, которая увеличивает значение на 1
   decrement = (+(-1))   -- Функция, которая уменьшает аргумент на 1
   ```
   Здесь `increment` будет эквивалентно `\x -> x + 1`, а `decrement` — `\x -> x + (-1)`.

2. **Сечение для оператора деления**:
   ```haskell
   half = (/2)           -- Делит аргумент на 2
   reciprocal = (2/)     -- Делит 2 на аргумент
   ```
   Здесь `half` будет эквивалентно `\x -> x / 2`, а `reciprocal` — `\x -> 2 / x`.

3. **Сечение для оператора сравнения**:
   ```haskell
   isPositive = (>0)     -- Проверка, что значение больше 0
   isNegative = (<0)     -- Проверка, что значение меньше 0
   ```
   Функции `isPositive` и `isNegative` можно использовать для фильтрации списка, например:
   ```haskell
   filter isPositive [1, -2, 3, -4] -- Результат: [1, 3]
   ```

4. **Сечение для оператора конкатенации**:
   ```haskell
   addPrefix = ("Hello, " ++)
   ```
   `addPrefix "world!"` даст результат `"Hello, world!"`.

### Оператор `$`

`$` в Haskell — это специальный оператор, который помогает избежать лишних скобок в выражениях. Он имеет низкий приоритет (0) и правую ассоциативность, что позволяет использовать его для записи функций, которые применяются к результатам других функций.

#### Как работает `$`
Оператор `$` просто применяет функцию к аргументу. Его определение:
```haskell
($) :: (a -> b) -> a -> b
f $ x = f x

infixr 0 $
```

Также `$` применяется для упрощения записи, когда есть несколько вложенных функций, так как его низкий приоритет позволяет избежать скобок:
```haskell
-- Без использования $
sqrt (1 + 2 * 3)
-- С использованием $
sqrt $ 1 + 2 * 3
```

#### Примеры применения `$`
Использование `$` особенно полезно, когда нужно применить последовательность функций к значению:
```haskell
map ($ 2) [(+3), (*5), (^2)]
-- результат [5,10,4] — это [2+3, 2*5, 2^2]
```
Или в более сложных случаях:
```haskell
sum $ map (^2) $ filter even [1..10]
-- результат 220 — сумма квадратов четных чисел от 1 до 10
```

## Полиморфизм функций

Полиморфизм функций в Haskell позволяет создавать функции, которые могут работать с данными разных типов, не изменяя их код. В Haskell существуют несколько видов полиморфизма:

1. **Параметрический полиморфизм.**
2. **Ограниченный (ад-хок) полиморфизм.**
3. **Полиморфизм более высокого рода.**

### Параметрический полиморфизм
Параметрический полиморфизм позволяет функции принимать значения любого типа, не ограничиваясь каким-либо конкретным. Это достигается с помощью **параметров типа** (например, `a`, `b`):

```haskell
identity :: a -> a
identity x = x
```
Функция `identity` возвращает тот же элемент, который она получила в аргументе. Тип `a -> a` означает, что функция может принимать аргумент любого типа и возвращать значение того же типа.

Функция `map` также является примером параметрического полиморфизма:
```haskell
map :: (a -> b) -> [a] -> [b]
```
`map` принимает функцию `(a -> b)` и список `[a]`, а затем возвращает список `[b]`, применяя функцию к каждому элементу списка `[a]`. Типы `a` и `b` могут быть любыми, что делает `map` универсальной.

### Ограниченный (ад-хок) полиморфизм
Ограниченный полиморфизм, или **полиморфизм классов типов**, позволяет функции работать с разными типами, которые принадлежат к определенному классу типов. В этом случае тип функции ограничивается определенными требованиями, и для каждого допустимого типа может быть своя реализация:

```haskell
sum :: Num a => [a] -> a
sum []     = 0
sum (x:xs) = x + sum xs
```
В функции `sum` тип ограничен классом `Num`. Ограничение `Num a =>` означает, что `a` должен быть числовым типом. Это позволяет `sum` работать с любыми числовыми типами (`Int`, `Float`, `Double` и т.д.), но не с другими типами (например, `String`).

Функция `maximum` находит максимальное значение в списке. Она требует, чтобы тип `a` был в классе `Ord`, который поддерживает операции сравнения.
```haskell
maximum :: Ord a => [a] -> a
```

### Полиморфизм более высокого рода
Haskell поддерживает полиморфизм более высокого рода, что позволяет работать с типами, принимающими другие типы в качестве аргументов. Такой полиморфизм позволяет создавать и использовать абстракции более высокого уровня:

```haskell
fmap :: Functor f => (a -> b) -> f a -> f b
```
Функция `fmap` принимает функцию `(a -> b)` и контейнер типа `f a`, возвращая контейнер типа `f b`. Здесь `f` — это полиморфный тип-контейнер, такой как `Maybe`, `List`, `Either` и другие, которые являются функторными типами (имеют экземпляры класса `Functor`).

## Условные конструкции
В Haskell условные конструкции играют важную роль, так как позволяют выбирать результат вычислений на основе условий. Несмотря на функциональную природу языка, Haskell предоставляет несколько механизмов для обработки условий: `if-then-else`, выражения `case` и охранные выражения (`guards`).

### Конструкция `if-then-else`

Конструкция `if-then-else` используется для простых ветвлений в Haskell. Она аналогична условным выражениям в других языках, но отличается тем, что `else` обязательно — функция в Haskell должна возвращать значение для каждого случая:
```haskell
-- Синтаксис
if условие
then результат1
else результат2
-- Пример
absolute :: Int -> Int
absolute x = if x < 0
             then -x
             else x
```

Здесь функция `absolute` возвращает отрицательное значение `x`, если `x` меньше `0`; иначе — возвращает `x` как есть.
**Примечание**: Так как `if` является выражением, оно всегда возвращает значение. Конструкция `if-then` без `else` вызовет ошибку.

### Конструкция `case ... of`

Конструкция `case ... of` используется для сопоставления с образцом (pattern matching) и обработки различных структур данных, например списков, кортежей и пользовательских типов данных. Она позволяет развернуть значение в зависимости от конкретного шаблона.
Рассмотрим функцию, которая определяет тип списка как пустой, одноэлементный или длинный:

```haskell
-- Синтаксис
case выражение of
  шаблон1 -> результат1
  шаблон2 -> результат2
  ...
  _       -> результат по умолчанию
-- Пример
describeList :: [a] -> String
describeList lst = case lst of
  []      -> "Пустой список"
  [x]     -> "Список с одним элементом"
  (x:xs)  -> "Список с более чем одним элементом"
```

Здесь:
- Если список пустой (`[]`), результат будет `"Пустой список"`.
- Если список содержит один элемент (`[x]`), результат — `"Список с одним элементом"`.
- Если список содержит несколько элементов (`(x:xs)`), результат — `"Список с более чем одним элементом"`.

Конструкция `case` часто используется, когда нужно проверить и разобрать значение сложной структуры, такой как список, дерево или пользовательский тип данных.

### Охранные выражения (guards)

Охранные выражения (или guards) позволяют условно разветвлять логику внутри функции без использования `if-then-else`. Они делают код более читаемым, особенно при наличии нескольких условий. Охранные выражения записываются после имени функции и символа `|` и являются логическими выражениями, которые должны быть `True` для выполнения соответствующего результата.
Определим функцию `bmiCategory`, которая оценивает категорию индекса массы тела (BMI):

```haskell
-- Синтаксис
имяФункции аргументы
  | условие1 = результат1
  | условие2 = результат2
  | otherwise = результат по умолчанию
-- Пример
bmiCategory :: Double -> String
bmiCategory bmi
  | bmi < 18.5 = "Недостаточный вес"
  | bmi < 25.0 = "Нормальный вес"
  | bmi < 30.0 = "Избыточный вес"
  | otherwise  = "Ожирение"
```

Здесь `otherwise` — это псевдоним для `True`, который используется как «условие по умолчанию» для случаев, когда ни одно из предыдущих условий не выполнено.
- Если bmi меньше 18.5, возвращается `"Недостаточный вес"`.
- Если bmi меньше 25.0 (но больше или равно 18.5), возвращается `"Нормальный вес"`.
- Если bmi меньше 30.0 (но больше или равно 25.0), возвращается `"Избыточный вес"`.
- Для всех остальных значений bmi возвращается `"Ожирение"`.


## Сопоставление с образцом

**Паттерн-матчинг** (сопоставление с образцом) в Haskell — это способ разобрать данные и обработать их в зависимости от их формы. Он делает код более читабельным и позволяет легко обрабатывать разные структуры данных, такие как примитивные типы, списки, строки, кортежи и пользовательские типы.

### Паттерн-матчинг с примитивными типами данных

Паттерн-матчинг с примитивными типами данных используется для сопоставления с конкретными значениями, что позволяет писать функции, которые обрабатывают определенные случаи. Например:

```haskell
describeNumber :: Int -> String
describeNumber 0 = "Ноль"
describeNumber 1 = "Один"
describeNumber _ = "Другое число"
```

Здесь функция `describeNumber` принимает целое число и возвращает строку в зависимости от конкретного значения. Символ `_` используется как “любой другой случай”.

### Паттерн-матчинг со списками и строками

Списки и строки в Haskell представляют собой последовательности, и для их обработки можно использовать разные шаблоны.

#### Основные паттерны для списков

- **Пустой список**: `[]`
- **Список с головой и хвостом**: `(x:xs)`, где `x` — это первый элемент (голова), а `xs` — остальные элементы (хвост)

Пример функции, которая возвращает описание списка в зависимости от его структуры:

```haskell
describeList :: [Int] -> String
describeList []     = "Пустой список"
describeList [x]    = "Список с одном элементом: " ++ show x
describeList [x,y]  = "Список с двумя элементами: " ++ show x ++ " и " ++ show y
describeList (x:xs) = "Список со множеством элементов, начиная с " ++ show x
```

#### Паттерн-матчинг для строк

Строки в Haskell — это списки символов `[Char]`, поэтому к ним можно применять те же паттерны, что и к спискам:

```haskell
describeString :: String -> String
describeString "" = "Пустая строка"
describeString [x] = "Одиночный символ: " ++ [x]
describeString (x:xs) = "Первый символ длинной строки: " ++ [x]
```

### Паттерн-матчинг с кортежами

Кортежи позволяют сопоставлять данные с фиксированным количеством элементов. Это удобно, когда функция должна обработать несколько значений одновременно.

#### Пример: обработка кортежа с двумя элементами

```haskell
addVectors :: (Int, Int) -> (Int, Int) -> (Int, Int)
addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)
```

Функция `addVectors` складывает два двумерных вектора, представленных как кортежи `(Int, Int)`. Здесь используются паттерны `(x1, y1)` и `(x2, y2)`, чтобы извлечь компоненты векторов для сложения.

#### Пример: обработка кортежей с более чем двумя элементами


```haskell
describeTriple :: (Int, Int, Int) -> String
describeTriple (0, 0, 0) = "Все нули!"
describeTriple (x, 0, 0) = "Первое число не ноль"
describeTriple (0, y, 0) = "Второе число не ноль"
describeTriple (0, 0, z) = "Третье число не ноль"
describeTriple _         = "Смешанные значения"
```

### Паттерн-матчинг с пользовательскими типами

Пользовательские типы (например, типы, определенные через `data`) особенно удобно обрабатывать с помощью паттерн-матчинга, позволяя работать с каждым конструктором типа отдельно.

#### Пример: обработка типа Maybe

`Maybe` — стандартный тип данных, представляющий значение, которое может быть либо `Just` (существующее значение), либо `Nothing` (отсутствие значения):

```haskell
data Maybe a = Just a | Nothing
describeMaybe :: Maybe Int -> String
describeMaybe Nothing = "Нет значения"
describeMaybe (Just x) = "Значение: " ++ show x
```

#### Пример: обработка типа Shape

Рассмотрим пример типа `Shape`, представляющего различные фигуры:

```haskell
data Shape = Circle Float | Rectangle Float Float
area :: Shape -> Float
area (Circle r) = pi * r ^ 2
area (Rectangle w h) = w * h
```

Здесь `Shape` может быть либо `Circle` с радиусом `r`, либо `Rectangle` с шириной `w` и высотой `h`. Паттерн-матчинг позволяет функции `area` по-разному вычислять площадь в зависимости от конкретного конструктора (`Circle` или `Rectangle`).

## Рекурсия

В Haskell отсутствуют стандартные императивные циклы (`for`, `while`), и для итеративных вычислений используется рекурсия и функции высшего порядка. Ленивые вычисления позволяют реализовывать сложные вычисления с использованием рекурсии без значительных затрат памяти. Рассмотрим, как подсчитать сумму всех элементов списка:

```haskell
sumList :: [Int] -> Int
sumList [] = 0                    -- Базовый случай: если список пуст, то сумма равна 0
sumList (x:xs) = x + sumList xs   -- Рекурсивный случай: складываем первый элемент и сумму оставшихся элементов
```

### Прямая рекурсия
Прямая рекурсия — это когда функция вызывает саму себя. Этот тип рекурсии подходит для простых задач, но не всегда эффективен с точки зрения использования памяти.

**Пример**: вычисление факториала:

```haskell
factorial :: Integer -> Integer
factorial 0 = 1
factorial n = n * factorial (n - 1)
```

Здесь `factorial` вызывает саму себя для вычисления факториала числа. При каждом вызове она удерживает в памяти частичные вычисления до самого конца. Вызов `factorial 5` вернет 120.

### Хвостовая рекурсия
Хвостовая рекурсия — это вид рекурсии, где рекурсивный вызов является последней операцией в функции. Хвостовая рекурсия эффективнее с точки зрения оптимизации, так как компилятор может оптимизировать ее до обычного цикла и не накапливать контекст вызовов в памяти.

**Пример**: хвостовая версия факториала с аккумулятором:

```haskell
factorialTail :: Integer -> Integer
factorialTail n = go n 1
  where
    go 0 acc = acc -- Базовый случай: возвращаем накопленное значение
    go n acc = go (n - 1) (n * acc)  -- Рекурсивный случай с хвостовой рекурсией
```


В этом примере используется вспомогательная функция `go` с дополнительным параметром `acc`, который накапливает результат. Последний вызов функции — это вызов самой `go`, что делает ее хвостовой рекурсией. Вызов `factorialTail 5` также вернет 120.

### Косвенная рекурсия
Косвенная рекурсия происходит, когда функция `A` вызывает функцию `B`, а `B`, в свою очередь, вызывает `A`. Эта цепочка вызовов может быть сложной и многозвенной.

**Пример**: проверка, является ли число четным или нечетным, с использованием двух функций:

```haskell
isEven :: Integer -> Bool
isEven 0 = True
isEven n = isOdd (n - 1)

isOdd :: Integer -> Bool
isOdd 0 = False
isOdd n = isEven (n - 1)
```

Здесь `isEven` вызывает `isOdd`, а `isOdd` вызывает `isEven`. Вместе они проверяют четность или нечетность числа.
Вызовы:
- `isEven 4` вернет `True`.
- `isOdd 3` вернет `True`.

## Функции высшего порядка

Функции высшего порядка (higher-order functions) — это функции, которые принимают другие функции в качестве аргументов или возвращают функции в качестве результата. В Haskell они играют важную роль, позволяя создавать более абстрактный, читабельный и лаконичный код.

### Основные функции высшего порядка в Haskell
Haskell предлагает множество встроенных функций высшего порядка, которые позволяют легко и эффективно работать с данными. Рассмотрим некоторые из них.

1. **map**

    Функция `map` применяет переданную функцию ко всем элементам списка, возвращая новый список:

    ```haskell
    -- Сигнатура
    map :: (a -> b) -> [a] -> [b]
    -- (a -> b) — функция, которая преобразует элемент типа a в элемент типа b.
    -- [a] — исходный список элементов типа a.
    -- [b] — новый список элементов типа b.

    -- Пример использования
    doubleList :: [Int] -> [Int]
    doubleList = map (* 2)  -- Удваивает каждый элемент в списке

    -- Пример вызова
    doubleList [1, 2, 3] -- Результат: [2, 4, 6]
    ```

    Здесь `map (* 2)` возвращает новый список, в котором каждый элемент исходного списка удвоен.

2. **filter**

    Функция `filter` принимает предикат (функцию, возвращающую `Bool`) и возвращает список только тех элементов, которые удовлетворяют этому предикату:

    ```haskell
    -- Сигнатура
    filter :: (a -> Bool) -> [a] -> [a]
    -- (a -> Bool) — предикат, который проверяет выполнение условия для каждого элемента.
    -- [a] — исходный список.
    -- [a] — новый список, содержащий только те элементы, для которых предикат вернул True.

    -- Пример использования
    evenNumbers :: [Int] -> [Int]
    evenNumbers = filter even    -- Оставляет только четные числа

    -- Пример вызова
    evenNumbers [1, 2, 3, 4, 5]  -- Результат: [2, 4]
    ```

    Функция `filter even` возвращает новый список, в который включены только четные числа исходного списка.

3. **foldr и foldl**

    Функции `foldr` и `foldl` используются для сведения списка к одному значению. Они применяют заданную функцию ко всем элементам списка, аккумулируя результат:

    ```haskell
    -- Сигнатура foldr
    foldr :: (a -> b -> b) -> b -> [a] -> b
    -- (a -> b -> b) — функция, которая принимает текущий элемент списка a и промежуточное значение b, возвращая обновленное значение b.
    -- b — начальное значение аккумулятора.
    -- [a] — исходный список.
    -- b — окончательное свернутое значение.

    -- Пример использования foldr
    sumList :: [Int] -> Int
    sumList = foldr (+) 0   -- Складывает все элементы списка
    -- Пример вызова
    sumList [1, 2, 3, 4]    -- Результат: 10
    ```

    Здесь `foldr (+) 0` складывает все элементы списка, начиная с начального значения 0.

    Отличие `foldr` от `foldl`:
    - `foldr` (правое свертывание) обрабатывает список справа налево.
    - `foldl` (левое свертывание) обрабатывает список слева направо. В больших списках `foldl'` (из модуля Data.List) более эффективен, так как вычисляет значения по мере их получения, избегая накопления вызовов в стеке.

    Пример использования `foldl`:

    ```haskell
    productList :: [Int] -> Int
    productList = foldl (*) 1   -- Умножает все элементы списка
    -- Пример вызова
    productList [1, 2, 3, 4]    -- Результат: 24
    ```

4. **zipWith**

    Функция `zipWith` применяет переданную функцию к соответствующим элементам двух списков и возвращает новый список:

    ```haskell
    -- Сигнатура
    zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
    -- (a -> b -> c) — функция, которая объединяет элементы двух списков.
    -- [a] и [b] — исходные списки.
    -- [c] — новый список, полученный объединением.

    -- Пример использования:
    addLists :: [Int] -> [Int] -> [Int]
    addLists = zipWith (+)    -- Складывает соответствующие элементы двух списков
    -- Пример вызова
    addLists [1, 2, 3] [4, 5, 6]    -- Результат: [5, 7, 9]
    ```

### Преимущества использования функций высшего порядка
Функции высшего порядка делают код более гибким, кратким и выразительным:
- **Абстракция**: позволяют обобщать повторяющиеся структуры, как, например, обход списка с `map`.
- **Модульность**: функции высшего порядка можно легко комбинировать и повторно использовать, создавая модульные компоненты.
- **Читаемость**: код становится более декларативным, что улучшает читаемость, так как выражает намерения без явного написания алгоритмов.