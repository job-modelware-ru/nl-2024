# Haskell. Типы данных и переменные
Презентацию выполнили студенты гр. 5030102/10201:
- Костюхин Алексей
- Тасаков Антон
- Теплов Андрей

## Содержание

- [Тип Char](#тип-char)
    - [Функции из модуля Data.Char](#функции-из-модуля-datachar)
    - [Управляющие последовательности](#управляющие-последовательности)
- [Тип Bool](#тип-bool)
    - [Операции `&&`, `||`, `not`](#операции---not)
    - [Операторы `==`, `/=`, `<=`, `>=`, `>`, `<`](#операторы------)
    - [Оператор `if-then-else`](#оператор-if-then-else)
- [Числовые типы](#числовые-типы)
- [Приведение типов](#приведение-типов)
- [Строки и списки](#строки-и-списки)
    - [`String` синоним `[Char]`](#string-синоним-char)
    - [Списки и параметрический полиморфизм](#списки-и-параметрический-полиморфизм)
    - [Операции со строками и списками](#операции-со-строками-и-списками)
- [Кортежи](#кортежи)
- [Примеры простых функций и области видимости](#примеры-простых-функций-и-области-видимости)
- [Пользовательские типы данных](#пользовательские-типы-данных)
- [Пример реализации экземпляра класса типа `Eq`](#пример-реализации-экземпляра-класса-типа-eq)
- [Полиморфизм числовых типов](#полиморфизм-числовых-типов)

## Тип Char
Описание типа `Char` и функций для работы с ним находится в модуле `Data.Char`. Кроме того, он включён в пакет `Prelude`, который *подключается ко всем программам по умолчанию*.

Тип `Char` в Haskell представляет отдельный символ. Символы заключаются в одиночные кавычки, например, `'a'`, `'1'`, или `'$'`. В Haskell `Char` является 32-битным, что означает поддержку символов Unicode, охватывающих множество языков, а также специальные и акцентированные символы, например `'λ'`.

### Функции из модуля Data.Char
Некоторые функции из модуля `Data.Char` для работы с типом `Char` (*комментарии над функциями описывают их тип, а справа - результат*):

- Функция `ord` принимает в качестве аргумента переменную типа `Char` и возвращает числовое значение символа в Unicode (тип `Int`).
    ```haskell
    -- ord :: Char -> Int
    ord 'a' -- -> 97
    ```
- Функция `chr` возвращает символ по числовому значению.
    ```haskell
    -- chr :: Int -> Char
    chr 97 -- -> 'a'
    ```
- Функция `isAlpha` проверяет, является ли символ буквой.
    ```haskell
    -- isAlpha :: Char -> Bool
    isAlpha 'a' -- -> True
    isAlpha '9' -- -> False
    ```
- Функция `isDigit`  проверяет, является ли символ цифрой.
    ```haskell
    -- isDigit :: Char -> Bool
    isDigit 'a' -- -> False
    isDigit '9' -- -> True
    ```

### Управляющие последовательности
- `'\a'` - подача звукового сигнала
- `'\b'` - возврат на один символ
- `'\f'` - перевод страницы
- `'\n'` - конец строки
- `'\r'` - возврат каретки
- `'\t'` - горизонтальная табуляция
- `'\v'` - вертикальная табуляция
- `'\\'` - обратная косая черта
- `'\''` - одинарная кавычка
- `'\"'` - двойная кавычка
- `'\oOO'` - символ с кодом Unicode в восьмеричном формате (`'\o141'` == `'a'`)
- `'\xHH'` - символ с кодом Unicode в шестнадцатеричном формате (`'\x61'` == `'a'`)
- `'\DD'` - символ с кодом Unicode в десятеричном формате (`'\97'` == `'a'`)
- `'\0'` или `'\NUL'` - нулевой символ

## Тип Bool

В Haskell, `Bool` — это логический тип данных, который может принимать одно из двух значений:
- `True` — истина;
- `False` — ложь.

### Операции `&&`, `||`, `not`

1. `&&` (логическое “И”).
Возвращает `True`, если оба выражения истинны.
    ```haskell
    True && True  -- True
    True && False -- False
    ```

2.	`||`  (логическое “ИЛИ”).
Возвращает `True`, если хотя бы одно из выражений истинно.
    ```haskell
    True || False -- True
    False || False -- False
    ```

3.	`not`  (логическое “НЕ”).
Инвертирует значение: превращает `True` в `False` и наоборот.
    ```haskell
    not True  -- False
    not False -- True
    ```
### Операторы `==`, `/=`, `<=`, `>=`, `>`, `<`

1. `==` — равно;
2. `/=` — не равно;
3. `<=` — меньше или равно;
4. `>=` — больше или равно;
5. `>` — больше;
6. `<` — меньше.

### Оператор `if-then-else`

В Haskell конструкция `if-then-else` используется для выполнения условий. Важно, чтобы она содержала все три части: `if`, `then`, и `else`.
```haskell
if True then '1' else '0'
```
Тип результата в конструкции `if-then-else` должен быть одинаковым для ветвей `then` и `else`. Например, обе ветви должны возвращать значения одного типа, будь то числа, символы или строки.
```haskell
if False then True else '0'
```


## Числовые типы
-  `Int` — целое число со знаком с фиксированным диапазоном.
Диапазон: $-2^{31}$ до $2^{31} - 1$ (на 32-битной системе).
    ```haskell
    intValue :: Int
    intValue = 42
    intNegative :: Int
    intNegative = -100
    -- Пример переполнения (если тип ограничен 32 битами)
    -- let overflow = 2^31 :: Int  -- Ошибка: значение выходит за пределы диапазона.
    ```
-  `Word` — целое число без знака, с размерами, зависящими от платформы (например, 32-битное или 64-битное). Такого же размера, что и тип `Int`.
    ```haskell
    wordValue :: Word
    wordValue = 255
    -- Ошибка: отрицательное значение недопустимо
    -- let invalidWord = -1 :: Word  -- Приведет к ошибке компиляции
    ```
-  `Integer` - целое число со знаком произвольного размера.
В отличие от `Int`, этот тип не ограничен фиксированным диапазоном. Он может представлять очень большие числа, ограниченные только доступной памятью.
    ```haskell
    bigNumber :: Integer
    bigNumber = 123456789012345678901234567890
    -- Поддерживаются даже очень большие числа
    anotherBigNumber :: Integer
    anotherBigNumber = 2 ^ 100
    ```
-  `Float` - число с плавающей точкой одинарной точности (32 бита).
Это приближенное представление для чисел с десятичной дробной частью, но с возможными погрешностями.
    ```haskell
    floatValue :: Float
    floatValue = 3.14
    floatCalculation :: Float
    floatCalculation = 1.0 / 3.0  -- Результат: 0.33333334 (погрешность!)
    ```
-  `Double` - число с плавающей точкой двойной точности (64 бита).
Представляет более точное приближение, чем `Float`, но все равно подвержено погрешностям.
    ```haskell
    doubleValue :: Double
    doubleValue = 3.141592653589793
    -- Дробь с большей точностью
    doubleCalculation :: Double
    doubleCalculation = 1.0 / 3.0  -- Результат: 0.3333333333333333
    ```
-  Тип `Ratio` в Haskell используется для работы с рациональными числами. Он представляет точное представление дробей, избегая ошибок, связанных с арифметикой с плавающей точкой (`Float` и `Double`).
   - Для работы с рациональными числами используется модуль `Data.Ratio`.
   - Рациональное число задается с помощью конструктора `%`:
        ```haskell
        ratioValue :: Ratio
        ratioValue = 3 % 4 -- рациональное число 3/4
        ```

-  `Complex` - используется для работы с комплексными числами.
   - Действительная и мнимая части могут быть числами с плавающей точкой или другими типами, принадлежащими классу типов `Num`.
   - Для работы с комплексными числами используется модуль `Data.Complex`.
   - Комплексное число задается с помощью конструктора `:+`:
        ```haskell
        exampleComplex :: Complex Double
        exampleComplex = 3 :+ 4 -- 3.0 + 4.0i
        ```


## Приведение типов
Функции `fromInteger`, `toInteger`, `fromRational`, `toRational` используются для преобразования между различными числовыми типами, но важно учитывать возможные потери точности, особенно при работе с числами с плавающей точкой.

1. `fromInteger`
Преобразует целое число (`Integer`) в другой числовой тип. Полезно, когда нужно работать с числами разных типов (например, преобразовать `Integer` в `Float`, `Double` или даже `Complex`).
    ```haskell
    fromInteger 5 :: Float    -- Результат: 5.0
    fromInteger 7 :: Complex Double  -- Результат: (7.0 :+ 0.0)
    ```
2. `toInteger`
Преобразует число (например, `Int`, `Float`, `Rational`) в `Integer`. Для дробных чисел дробная часть будет отброшена.
    ```haskell
    toInteger (3.14 :: Float)   -- Результат: 3
    toInteger (5 % 2)           -- Результат: 2
    ```
3. `fromRational`
Преобразует рациональное число (`Rational`) в другой числовой тип, например, `Float` или `Double`.
    ```haskell
    fromRational (3 % 4) :: Float    -- Результат: 0.75
    fromRational (2 % 5) :: Complex Double  -- Результат: (0.4 :+ 0.0)
    ```
4. `toRational`
Преобразует число в тип `Rational`. Для чисел с плавающей точкой может вернуть приближенное значение.
    ```haskell
    toRational (0.75 :: Float)  -- Результат: 3 % 4
    toRational (1.2 :: Double)  -- Результат: 5404319552844595 % 4503599627370496
    ```


## Строки и списки
### `String` синоним `[Char]`
В Haskell строки и списки тесно связаны. Фактически, строка (`String`) — это синоним списка символов (`[Char]`).
В Haskell:
```haskell
newtype String = [Char]
"hello" == ['h', 'e', 'l', 'l', 'o']  -- True
```
Строки поддерживают все операции, применимые к спискам, такие как конкатенация, доступ к элементам и перебор.

### Списки и параметрический полиморфизм
Списки — это упорядоченные коллекции элементов одного типа. Тип элемента задается параметрически:
```haskell
list :: [a]  -- Параметрический тип списка (a может быть любым типом)
list = [1, 2, 3]  -- Здесь a = Int
```
Списки в Haskell:
- Поддерживают параметрический полиморфизм — функции и структуры данных могут работать с любым типом.
- Могут быть пустыми: `[]`.
- Используют ленивые вычисления, т.е. элементы вычисляются по мере необходимости.

### Операции со строками и списками

1. Конкатенация списков `(++)`.
Объединяет два списка:
    ```haskell
    "Hello" ++ " World"  -- "Hello World"
    [1, 2] ++ [3, 4]     -- [1, 2, 3, 4]
    ```
2. Оператор добавления элемента `(:)`.
Добавляет элемент в начало списка (или строки):
    ```haskell
    'h' : "ello"    -- "hello"
    1 : [2, 3, 4]   -- [1, 2, 3, 4]
    ```
3. `reverse`.
Переворачивает список или строку:
    ```haskell
    reverse "hello"    -- "olleh"
    reverse [1, 2, 3]  -- [3, 2, 1]
    ```
4. `null`.
Проверяет, пустой ли список (или строка):
    ```haskell
    null []       -- True
    null "hello"  -- False
    ```
5. `head`.
Возвращает первый элемент списка:
    ```haskell
    head [1, 2, 3]   -- 1
    head "hello"     -- 'h'
    ```
    *Применение `head` к пустому списку вызовет ошибку*.

6. `tail`.
Возвращает список без первого элемента:
    ```haskell
    tail [1, 2, 3]   -- [2, 3]
    tail "hello"     -- "ello"
    ```
    *Применение `tail` к пустому списку также вызовет ошибку*.

7. `or` и `and`.
Проверяют логические значения в списке:
    - `or`: возвращает `True`, если хотя бы один элемент в списке равен `True`.
    - `and`: возвращает `True`, если все элементы в списке равны `True`.
    ```haskell
    or [False, True, False]  -- True
    and [True, True, False]  -- False
    ```


## Кортежи
Кортежи — это структуры фиксированной длины, содержащие элементы различных типов (в отличие от списков).

1. Конструкторы кортежей: `(,)`.
- `(,)` — это конструктор для двухэлементного кортежа.
- Haskell поддерживает кортежи от 2 до 62 элементов.
    ```haskell
    tuple2 :: (Int, Char)
    tuple2 = (1, 'a')
    tuple9 :: (Int, Char, String, Bool, Double, Int, Char, Float, String)
    tuple9 = (1, 'b', "hello", True, 3.14, 42, 'x', 2.71, "world")
    ```

2. Доступ к элементам: `fst` и `snd`.
Для двухэлементных кортежей Haskell предоставляет функции `fst` и `snd`:
- `fst` — извлекает первый элемент из кортежа.
- `snd` — извлекает второй элемент из кортежа.
    ```haskell
    fst (42, "answer")  -- Результат: 42
    snd (42, "answer")  -- Результат: "answer"
    ```
    *Эти функции работают только для двухэлементных кортежей. Для кортежей с большим количеством элементов нужно использовать паттерн-матчинг*.


## Примеры простых функций и области видимости
В Haskell функции являются первоклассными значениями, и они могут принимать другие функции как аргументы или возвращать их. Ниже приведены примеры различных типов функций, а также объяснение области видимости с использованием `let` и `where`.

1. В Haskell функции без аргументов существуют и представляют собой выражения, **которые всегда возвращают одно и то же значение**. Их часто называют *константами*. Функция без аргументов похожа на переменную, но её значение вычисляется один раз и не изменяется.
    ```haskell
    piValue :: Double
    piValue = 3.14159
    -- Пример использования
    piValue  -- Результат: 3.14159
    ```
2. Функция от одной переменной принимает один аргумент и возвращает результат на его основе.
    ```haskell
    square :: Int -> Int
    square x = x * x
    -- Пример использования
    square 5  -- Результат: 25
    ```

3. Функция от многих переменных может принимать несколько аргументов. В Haskell функции по умолчанию частично применимы, что означает, что вы можете передать меньше аргументов, чем требуется, и получить новую функцию.
    ```haskell
    add :: Int -> Int -> Int
    add x y = x + y
    -- Пример использования
    add 3 4      -- Результат: 7
    (add 5) 2    -- Результат: 7
    ```
4. `let` и `where` используются для определения локальных переменных и функций, но у них есть различия в области видимости и синтаксисе.
    ```haskell
    calculate :: Int -> Int -> Int
    calculate x y = let z = x * 2
                     in z + y
    -- Пример использования
    calculate 3 4  -- Результат: 10
    ```
    *`let` позволяет определять переменные в выражении, которые доступны только в этом выражении*.

    ```haskell
    calculateWithWhere :: Int -> Int -> Int
    calculateWithWhere x y = z + y
        where z = x * 2
    -- Пример использования
    calculateWithWhere 3 4  -- Результат: 10
    ```
    *`where` позволяет определять переменные, которые доступны для всей функции*.


## Пользовательские типы данных
Haskell позволяет создавать пользовательские типы данных, что помогает структурировать код и делать его более читаемым. Существует два основных способа определения пользовательских типов: `newtype` и `data`.

1. `newtype` используется для создания нового типа, который оборачивает существующий тип. Это может быть полезно для добавления семантики, не создавая при этом дополнительной нагрузки.
    ```haskell
    -- Синтаксис
    newtype TypeName = ConstructorName ExistingType
    -- Пример
    newtype UserId = UserId Int
    ```
    В этом примере `UserId` — это новый тип, который оборачивает `Int`. Хотя `UserId` и `Int` имеют одинаковое представление, Haskell рассматривает их как разные типы, что помогает избежать ошибок.
    *Преимущества*:
    - Нет накладных расходов, так как `newtype` не создает дополнительной структуры (выводит тот же самый внутренний тип).
    - Может использоваться для определения экземпляров классов типов.

2. `data` используется для определения более сложных пользовательских типов данных, которые могут включать несколько конструкторов, каждый из которых может принимать аргументы.
    ```haskell
    -- Синтаксис
    data TypeName = Constructor1 Type1 Type2 | Constructor2 Type3
    -- Пример
    data Shape = Circle Float | Rectangle Float Float
    area :: Shape -> Float
    area (Circle r) = pi * r^2
    area (Rectangle w h) = w * h
    ```
    В этом примере `Shape` — это тип данных, который может быть либо `Circle` с радиусом типа `Float`, либо `Rectangle` с шириной и высотой типа `Float`.

3. Ключевое слово `deriving` используется для автоматического создания экземпляров классов типов для пользовательских типов данных. Это позволяет использовать стандартные функции (например, `Eq`, `Show`, `Ord`) с пользовательскими типами.
    ```haskell
    -- Синтаксис
    data TypeName = ConstructorName Type1 Type2 deriving (TypeClass1, TypeClass2)
    -- Пример
    data Color = Red | Green | Blue deriving (Show, Eq)
    show Red   -- "Red"
    Green == Blue   -- False
    ```
    Теперь для `Color` доступны функции `show` (для преобразования в строку) и `==` (для сравнения).


## Пример реализации экземпляра класса типа `Eq`

Ключевого слова `deriving` может быть не достаточно:
- Автоматически сгенерированные реализации могут быть недостаточны или не совсем подходят для конкретного типа данных.
- Иногда рекурсивные типы данных могут вызывать проблемы с `deriving`, особенно при автоматическом выводе `Eq`или `Ord`.
- Некоторые классы типов не поддерживают `deriving` для сложных типов. В таких случаях приходится реализовывать экземпляр вручную.

Определение класса типов `Eq`:
```haskell
type Eq :: * -> Constraint
class Eq a where
    (==) :: a -> a -> Bool
    (/=) :: a -> a -> Bool
    {-# MINIMAL (==) | (/=) #-}
```

Этот код определяет простой тип данных `Bit` и предоставляет его реализацию для сравнения с использованием класса типов `Eq`.

Здесь создаётся экземпляр класса типов `Eq` для типа `Bit`, что позволяет сравнивать значения `Bit` на равенство.

```haskell
data Bit = Zero | One

instance Eq Bit where
  (==) :: Bit -> Bit -> Bool
  (==) Zero Zero = True
  (==) One  One  = True
  (==) _    _    = False

Zero == One -- False
Zero /= One -- True
```

- **`(==) Zero Zero = True`**: если оба значения равны `Zero`, результат сравнения будет `True`.
- **`(==) One One = True`**: если оба значения равны `One`, результат сравнения также будет `True`.
- **`(==) _ _ = False`**: для всех других случаев (когда значения разные) результат будет `False`.

Реализация `Eq` также позволяет автоматически использовать оператор `(/=)` для неравенства, который основан на `(==)`.


## Полиморфизм числовых типов

Диаграмма отображает иерархию классов типов Haskell и их зависимость с числовыми типами. В Haskell классы определяют типы, которые поддерживают различные математические операции.

1. `Eq` — базовый класс для типов, которые поддерживают проверку на равенство.
    ```haskell
    type Eq :: * -> Constraint
    class Eq a where
        (==) :: a -> a -> Bool
        (/=) :: a -> a -> Bool
        {-# MINIMAL (==) | (/=) #-}
    ```

2. `Ord` — класс упорядоченых типов. Наследуется от `Eq`.
    ```haskell
    type Ord :: * -> Constraint
    class Eq a => Ord a where
        compare :: a -> a -> Ordering
        (<) :: a -> a -> Bool
        (<=) :: a -> a -> Bool
        (>) :: a -> a -> Bool
        (>=) :: a -> a -> Bool
        max :: a -> a -> a
        min :: a -> a -> a
        {-# MINIMAL compare | (<=) #-}
    ```

3. `Enum` — класс для типов, которые могут быть последовательно перечислены (например, `succ`, `pred`).
    ```haskell
    type Enum :: * -> Constraint
    class Enum a where
        succ :: a -> a
        pred :: a -> a
        toEnum :: Int -> a
        fromEnum :: a -> Int
        enumFrom :: a -> [a]
        enumFromThen :: a -> a -> [a]
        enumFromTo :: a -> a -> [a]
        enumFromThenTo :: a -> a -> a -> [a]
        {-# MINIMAL toEnum, fromEnum #-}
    ```

4. `Bounded` — класс для типов с минимальным и максимальным значением.
    ```haskell
    type Enum :: * -> Constraint
        class Enum a where
        succ :: a -> a
        pred :: a -> a
        toEnum :: Int -> a
        fromEnum :: a -> Int
        enumFrom :: a -> [a]
        enumFromThen :: a -> a -> [a]
        enumFromTo :: a -> a -> [a]
        enumFromThenTo :: a -> a -> a -> [a]
        {-# MINIMAL toEnum, fromEnum #-}
    ```

5. `Num` — базовый класс для всех числовых типов, поддерживающий основные арифметические операции. От него наследуются классы `Real`, `Integral`, `Fractional`.
    ```haskell
    type Num :: * -> Constraint
    class Num a where
        (+) :: a -> a -> a
        (-) :: a -> a -> a
        (*) :: a -> a -> a
        negate :: a -> a
        abs :: a -> a
        signum :: a -> a
        fromInteger :: Integer -> a
        {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}
    ```

6. `Real` — класс для типов, которые поддерживают операции над действительными числами. Наследуется от `Num` и `Ord`.
    ```haskell
    type Real :: * -> Constraint
    class (Num a, Ord a) => Real a where
        toRational :: a -> Rational
        {-# MINIMAL toRational #-}
    ```

7. `Integral` — класс для целых чисел. Наследуется от `Real` и `Enum`. Включает такие подтипы, как `Int` и `Integer`.
    ```haskell
    type Integral :: * -> Constraint
    class (Real a, Enum a) => Integral a where
        quot :: a -> a -> a
        rem :: a -> a -> a
        div :: a -> a -> a
        mod :: a -> a -> a
        quotRem :: a -> a -> (a, a)
        divMod :: a -> a -> (a, a)
        toInteger :: a -> Integer
        {-# MINIMAL quotRem, toInteger #-}
    ```

8. `Fractional` — класс для дробных чисел, поддерживающий операции деления. От него наследуется `Floating`.
    ```haskell
    type Fractional :: * -> Constraint
    class Num a => Fractional a where
        (/) :: a -> a -> a
        recip :: a -> a
        fromRational :: Rational -> a
        {-# MINIMAL fromRational, (recip | (/)) #-}
    ```

9. `Floating` — класс для чисел с плавающей точкой, таких как `Float` и `Double`.
    ```haskell
    type Floating :: * -> Constraint
    class Fractional a => Floating a where
        pi :: a
        exp :: a -> a
        log :: a -> a
        sqrt :: a -> a
        (**) :: a -> a -> a
        logBase :: a -> a -> a
        sin :: a -> a
        cos :: a -> a
        tan :: a -> a
        asin :: a -> a
        acos :: a -> a
        atan :: a -> a
        sinh :: a -> a
        cosh :: a -> a
        tanh :: a -> a
        asinh :: a -> a
        acosh :: a -> a
        atanh :: a -> a
        GHC.Float.log1p :: a -> a
        GHC.Float.expm1 :: a -> a
        GHC.Float.log1pexp :: a -> a
        GHC.Float.log1mexp :: a -> a
        {-# MINIMAL pi, exp, log, sin, cos, asin, acos, atan, sinh, cosh,
                    asinh, acosh, atanh #-}
    ```

10. `RealFrac` — класс для типов, которые поддерживают операции с дробными числами, с функциями для преобразования в целые числа. Наследуется от `Real` и `Fractional`.
    ```haskell
    type RealFrac :: * -> Constraint
    class (Real a, Fractional a) => RealFrac a where
        properFraction :: Integral b => a -> (b, a)
        truncate :: Integral b => a -> b
        round :: Integral b => a -> b
        ceiling :: Integral b => a -> b
        floor :: Integral b => a -> b
        {-# MINIMAL properFraction #-}
    ```

11. `RealFloat` — класс для чисел с плавающей точкой, поддерживающий точные операции. Наследуется от `RealFrac` и `Floating`.
    ```haskell
    type RealFloat :: * -> Constraint
    class (RealFrac a, Floating a) => RealFloat a where
        floatRadix :: a -> Integer
        floatDigits :: a -> Int
        floatRange :: a -> (Int, Int)
        decodeFloat :: a -> (Integer, Int)
        encodeFloat :: Integer -> Int -> a
        exponent :: a -> Int
        significand :: a -> a
        scaleFloat :: Int -> a -> a
        isNaN :: a -> Bool
        isInfinite :: a -> Bool
        isDenormalized :: a -> Bool
        isNegativeZero :: a -> Bool
        isIEEE :: a -> Bool
        atan2 :: a -> a -> a
        {-# MINIMAL floatRadix, floatDigits, floatRange, decodeFloat,
                    encodeFloat, isNaN, isInfinite, isDenormalized, isNegativeZero,
                    isIEEE #-}
    ```

Основные числовые типы, представленные на диаграмме:
- `Int` и `Integer` — целые числа.
- `Ratio` — рациональные числа.
- `Float` и `Double` — числа с плавающей точкой.
- `Complex` — комплексные числа.